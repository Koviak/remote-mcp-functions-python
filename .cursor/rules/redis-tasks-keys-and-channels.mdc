---
description: Redis task keys, JSON structures, and pub/sub channels used across this repo, with exact patterns and code references for quick navigation
alwaysApply: false
---
## Redis task-related keys and channels

Use these canonical keys and channels when storing, caching, or syncing tasks. Links reference the exact implementation sites.

### Primary task storage (agents)
- `annika:tasks:{id}` — primary agent task storage (no expiry)
  - Creation: see `create_agent_task_http` in [src/http_endpoints.py](mdc:src/http_endpoints.py)
    - Writes task JSON: `redis_client.set(f"annika:tasks:{task['id']}", json.dumps(task))`
  - Docs references: [src/Documentation/Planner_Agent_Task_Creation_Guide.md](mdc:src/Documentation/Planner_Agent_Task_Creation_Guide.md), [src/Documentation/Redis_First_Architecture_Summary.md](mdc:src/Documentation/Redis_First_Architecture_Summary.md)

#### Schema (authoritative Annika task object)
```json
{
  "type": "object",
  "required": ["id", "title", "planId"],
  "properties": {
    "id": {"type": "string", "description": "Unique task id, e.g. agent-task-<timestamp> or planner-<id>"},
    "title": {"type": "string"},
    "planId": {"type": "string"},
    "bucketId": {"type": ["string", "null"], "description": "Optional bucket id"},
    "assignedTo": {"type": "array", "items": {"type": "string"}, "description": "User IDs for assignment (agent creation path)"},
    "assigned_to": {"type": ["string", "null"], "description": "Display name mapping (adapter path)"},
    "dueDate": {"type": ["string", "null"], "description": "YYYY-MM-DD (agent path)"},
    "due_date": {"type": ["string", "null"], "description": "YYYY-MM-DD (adapter path)"},
    "percentComplete": {"type": ["number", "integer"], "minimum": 0, "maximum": 100},
    "percent_complete": {"type": "number", "minimum": 0, "maximum": 1},
    "status": {"type": ["string", "null"], "enum": ["not_started", "in_progress", "completed", null]},
    "priority": {"type": ["string", "integer", "null"], "description": "Adapter maps Graph priority int → enum"},
    "description": {"type": ["string", "null"]},
    "notes": {"type": ["string", "null"]},
    "labels": {"type": "array", "items": {"type": "string"}},
    "checklist_items": {"type": "array", "items": {"type": "object"}},
    "dependencies": {"type": "array", "items": {"type": "string"}},
    "blocking": {"type": "array", "items": {"type": "string"}},
    "attachments": {"type": "array", "items": {"type": "object"}},
    "notifications": {"type": "array", "items": {"type": "object"}},
    "bucket_id": {"type": ["string", "null"], "description": "Adapter path field name"},
    "order": {"type": ["string", "number", "null"]},
    "createdBy": {"type": ["string", "null"]},
    "createdAt": {"type": ["string", "null"], "description": "ISO timestamp from agent create path"},
    "created_at": {"type": ["string", "null"], "description": "ISO timestamp from adapter path"},
    "updated_at": {"type": ["string", "null"]},
    "completed_at": {"type": ["string", "null"]},
    "source": {"type": ["string", "null"], "description": "'agent' or 'planner'"},
    "external_id": {"type": ["string", "null"], "description": "Planner task id when source is planner"}
  },
  "additionalProperties": true
}
```

### Microsoft Graph task metadata cache
- `annika:graph:tasks:{task_id}` — cached Planner/Graph task metadata (persists; no TTL by design)
  - Constants: `REDIS_TASK_KEY` in [src/graph_metadata_manager.py](mdc:src/graph_metadata_manager.py)
  - Used by metadata HTTP mapping: [src/http_endpoints.py](mdc:src/http_endpoints.py) (resource → key mapping)

#### Schema (subset of Microsoft Graph plannerTask + details)
```json
{
  "type": "object",
  "required": ["id", "title", "planId"],
  "properties": {
    "id": {"type": "string"},
    "title": {"type": "string"},
    "planId": {"type": "string"},
    "bucketId": {"type": ["string", "null"]},
    "assignments": {"type": "object"},
    "percentComplete": {"type": "integer", "minimum": 0, "maximum": 100},
    "startDateTime": {"type": ["string", "null"]},
    "dueDateTime": {"type": ["string", "null"]},
    "createdDateTime": {"type": ["string", "null"]},
    "completedDateTime": {"type": ["string", "null"]},
    "orderHint": {"type": ["string", "null"]},
    "priority": {"type": ["integer", "null"]},
    "hasDescription": {"type": ["boolean", "null"]},
    "previewType": {"type": ["string", "null"]},
    "details": {"type": ["object", "null"], "description": "Response from /planner/tasks/{id}/details"}
  },
  "additionalProperties": true
}
```

### Temporary Planner task cache
- `annika:planner:tasks:{task_id}` — temporary cache (TTL ~1 hour)
  - Set with `setex(...)` in [src/http_endpoints.py](mdc:src/http_endpoints.py)

#### Schema
Same as the Microsoft Graph task cache schema above (planId/title/etc.), often a direct snapshot from Graph responses.

### Task lists (JSON documents)
- `annika:conscious_state` — global state JSON containing `task_lists`
  - JSON path: `$.task_lists.*.tasks[*]`
  - Read example: [src/annika_task_adapter.py](mdc:src/annika_task_adapter.py)

- `annika:consciousness:{conversation_id}:components:tasks` — conversation-specific task list JSON
  - JSON path: `$.active_conversation.tasks[*]`
  - Discovery/read example: [src/annika_task_adapter.py](mdc:src/annika_task_adapter.py)

#### Schema (task lists containers)
```json
{
  "type": "object",
  "properties": {
    "task_lists": {
      "type": "object",
      "additionalProperties": {
        "type": "object",
        "properties": {
          "buckets": {"type": ["array", "null"], "items": {"type": "object"}},
          "tasks": {"type": "array", "items": {"$ref": "#/$defs/AnnikaTask"}},
          "last_updated": {"type": ["string", "null"]}
        },
        "additionalProperties": true
      }
    },
    "active_conversation": {
      "type": "object",
      "properties": {
        "tasks": {"type": "array", "items": {"$ref": "#/$defs/AnnikaTask"}},
        "last_updated": {"type": ["string", "null"]}
      },
      "additionalProperties": true
    }
  },
  "$defs": {
    "AnnikaTask": {
      "type": "object",
      "required": ["id", "title"],
      "properties": {
        "id": {"type": "string"},
        "title": {"type": "string"}
      },
      "additionalProperties": true
    }
  },
  "additionalProperties": true
}
```

### Pub/Sub channels related to tasks
- `annika:tasks:updates` — publishes task create/update notifications
  - Published in: [src/http_endpoints.py](mdc:src/http_endpoints.py)
  - Consumed/subscribed in: [src/planner_sync_service_v4.py](mdc:src/planner_sync_service_v4.py), [src/planner_sync_service_v5.py](mdc:src/planner_sync_service_v5.py)

Payload schema (typical):
```json
{
  "type": "object",
  "required": ["action", "task"],
  "properties": {
    "action": {"type": "string", "enum": ["created", "updated", "deleted", "task_synced"]},
    "task": {"$ref": "#/$defs/AnnikaTask"},
    "source": {"type": ["string", "null"], "enum": ["agent", "planner", null]}
  },
  "$defs": {
    "AnnikaTask": {"type": "object", "additionalProperties": true}
  },
  "additionalProperties": true
}
```

- `annika:tasks:sync` — documented channel for sync confirmations (see docs)
  - Docs references: [src/Documentation/Planner_Agent_Task_Creation_Guide.md](mdc:src/Documentation/Planner_Agent_Task_Creation_Guide.md), [src/Documentation/Redis_First_Architecture_Summary.md](mdc:src/Documentation/Redis_First_Architecture_Summary.md)

- `annika:planner:webhook` — subscribed by v5 sync service for webhook-driven events
  - Subscription: [src/planner_sync_service_v5.py](mdc:src/planner_sync_service_v5.py)

### Related metadata keys for context
- `annika:graph:users:{user_id}`
- `annika:graph:groups:{group_id}`
- `annika:graph:plans:{plan_id}`
- `annika:graph:buckets:{bucket_id}`
  - Defined in: [src/graph_metadata_manager.py](mdc:src/graph_metadata_manager.py)

### Quick lookup mapping (HTTP metadata endpoint)
The metadata HTTP handler maps `type` → Redis key pattern:
- `user` → `annika:graph:users:{id}`
- `group` → `annika:graph:groups:{id}`
- `plan` → `annika:graph:plans:{id}`
- `task` → `annika:graph:tasks:{id}`

See mapping in: [src/http_endpoints.py](mdc:src/http_endpoints.py)

### Notes
- Tasks stored under `annika:tasks:{id}` are the authoritative, agent-facing store (no TTL).
- Planner/Graph task metadata (`annika:graph:tasks:{task_id}`) is a cache for fast reads and can be refreshed by sync/metadata services.
- Use RedisJSON when storing structured documents (e.g., `annika:conscious_state`, conversation task components), and string values for simple task objects unless/until JSON operations are needed.

## Additional Redis entries and schemas

### Token storage
- `{REDIS_NAMESPACE}tokens:agent:{scope}`
- `{REDIS_NAMESPACE}tokens:user:{user_id}:{scope}`
- `{REDIS_NAMESPACE}tokens:active` (set of keys)
- Source: [src/Documentation/REDIS_TOKEN_STORAGE_IMPLEMENTATION.md](mdc:src/Documentation/REDIS_TOKEN_STORAGE_IMPLEMENTATION.md), [src/mcp_redis_config.py](mdc:src/mcp_redis_config.py)

Schema (value for tokens:agent / tokens:user):
```json
{
  "type": "object",
  "required": ["token", "expires_on", "scope", "stored_at"],
  "properties": {
    "token": {"type": "string"},
    "expires_on": {"type": "integer"},
    "scope": {"type": "string"},
    "stored_at": {"type": "integer"},
    "refresh_count": {"type": "integer"},
    "user_id": {"type": ["string", "null"]},
    "metadata": {"type": ["object", "null"]}
  },
  "additionalProperties": true
}
```

### Planner sync service keys
- `annika:planner:id_map:{id}` — bidirectional Annika ↔ Planner id mappings
- `annika:planner:etag:{planner_id}` — ETag per Planner task
- `annika:sync:log` — list of sync log entries
- `annika:sync:pending` — list of queued operations
- `annika:sync:failed` — list of failed operations
- `annika:sync:webhook_status` — hash of webhook name → subscription id
- `annika:sync:health` — last health metrics snapshot
- `annika:sync:last_upload:{annika_id}` — ISO timestamp of last upload for an Annika task
- Source: [src/planner_sync_service_v5.py](mdc:src/planner_sync_service_v5.py)

Schemas:
- Id map values: string
```json
{"type": "string"}
```
- ETag values: string
```json
{"type": "string"}
```
- Sync log entry (`annika:sync:log` list items):
```json
{
  "type": "object",
  "required": ["timestamp", "operation", "status"],
  "properties": {
    "timestamp": {"type": "string"},
    "operation": {"type": "string"},
    "annika_id": {"type": ["string", "null"]},
    "planner_id": {"type": ["string", "null"]},
    "status": {"type": "string"},
    "error": {"type": ["string", "null"]},
    "conflict_resolution": {"type": ["string", "null"]}
  },
  "additionalProperties": true
}
```
- Pending/failed operations list items:
```json
{
  "type": "object",
  "required": ["type", "task_id", "timestamp"],
  "properties": {
    "type": {"type": "string"},
    "task_id": {"type": "string"},
    "timestamp": {"type": "string"}
  },
  "additionalProperties": true
}
```
- Webhook status hash (field → subscription id): values are string
```json
{"type": "string"}
```
- Sync health snapshot (`annika:sync:health`):
```json
{
  "type": "object",
  "required": ["timestamp", "processed_tasks", "pending_uploads", "failed_operations"],
  "properties": {
    "timestamp": {"type": "string"},
    "processed_tasks": {"type": "integer"},
    "pending_uploads": {"type": "integer"},
    "failed_operations": {"type": "integer"},
    "rate_limit_status": {"type": "string"},
    "webhook_status": {"type": "integer"},
    "consecutive_failures": {"type": "integer"}
  },
  "additionalProperties": true
}
```
- Last upload timestamp value: string (ISO)
```json
{"type": "string"}
```

### Teams notifications and history
- Channels:
  - `annika:teams:chat_messages`
  - `annika:teams:chats`
  - `annika:teams:channel_messages`
  - `annika:teams:channels`
- History lists:
  - `annika:teams:chat_messages:history`
  - `annika:teams:chats:history`
  - `annika:teams:channel_messages:history`
  - `annika:teams:channels:history`
- Source: [src/planner_sync_service_v5.py](mdc:src/planner_sync_service_v5.py)

Payload schemas:
- Chat message notification:
```json
{
  "type": "object",
  "required": ["timestamp", "type", "change_type", "chat_id", "message_id"],
  "properties": {
    "timestamp": {"type": "string"},
    "type": {"const": "teams_chat_message"},
    "change_type": {"type": "string"},
    "chat_id": {"type": "string"},
    "message_id": {"type": "string"},
    "client_state": {"type": ["string", "null"]},
    "resource": {"type": ["string", "null"]},
    "notification_id": {"type": ["string", "null"]},
    "raw_notification": {"type": ["object", "null"]}
  },
  "additionalProperties": true
}
```
- Chat notification:
```json
{
  "type": "object",
  "required": ["timestamp", "type", "change_type", "chat_id"],
  "properties": {
    "timestamp": {"type": "string"},
    "type": {"const": "teams_chat"},
    "change_type": {"type": "string"},
    "chat_id": {"type": "string"},
    "client_state": {"type": ["string", "null"]},
    "notification_id": {"type": ["string", "null"]},
    "raw_notification": {"type": ["object", "null"]}
  },
  "additionalProperties": true
}
```
- Channel message notification:
```json
{
  "type": "object",
  "required": ["timestamp", "type", "change_type", "team_id", "channel_id", "message_id"],
  "properties": {
    "timestamp": {"type": "string"},
    "type": {"const": "teams_channel_message"},
    "change_type": {"type": "string"},
    "team_id": {"type": "string"},
    "channel_id": {"type": "string"},
    "message_id": {"type": "string"},
    "client_state": {"type": ["string", "null"]},
    "resource": {"type": ["string", "null"]},
    "notification_id": {"type": ["string", "null"]},
    "raw_notification": {"type": ["object", "null"]}
  },
  "additionalProperties": true
}
```
- Channel notification:
```json
{
  "type": "object",
  "required": ["timestamp", "type", "change_type", "channel_id"],
  "properties": {
    "timestamp": {"type": "string"},
    "type": {"const": "teams_channel"},
    "change_type": {"type": "string"},
    "channel_id": {"type": "string"},
    "client_state": {"type": ["string", "null"]},
    "notification_id": {"type": ["string", "null"]},
    "raw_notification": {"type": ["object", "null"]}
  },
  "additionalProperties": true
}
```

### Chat subscriptions
- `annika:chat_subscriptions:{chat_id}` — hash: subscription state
- `annika:chat_subscriptions:global` — hash: global subscription state
- Source: [src/chat_subscription_manager.py](mdc:src/chat_subscription_manager.py)

Schema (hash fields → string values):
```json
{
  "type": "object",
  "properties": {
    "subscription_id": {"type": "string"},
    "created_at": {"type": "string"},
    "expires_at": {"type": "string"},
    "status": {"type": "string"}
  },
  "additionalProperties": true
}
```

### Graph notifications channels
- `annika:notifications:user`
- `annika:notifications:groups`
- `annika:notifications:planner`
- `annika:notifications:general`
- Source: [src/http_endpoints.py](mdc:src/http_endpoints.py)

Payload schema:
```json
{
  "type": "object",
  "required": ["type", "resource", "changeType"],
  "properties": {
    "type": {"const": "graph_notification"},
    "resource": {"type": "string"},
    "changeType": {"type": "string"},
    "resourceData": {"type": ["object", "null"]},
    "subscriptionId": {"type": ["string", "null"]},
    "timestamp": {"type": ["string", "null"]}
  },
  "additionalProperties": true
}
```

### Graph caches (metadata)
- `annika:graph:users:{user_id}`
- `annika:graph:groups:{group_id}`
- `annika:graph:plans:{plan_id}`
- `annika:graph:tasks:{task_id}` (schema defined above)
- `annika:graph:buckets:{bucket_id}`
- Source: [src/graph_metadata_manager.py](mdc:src/graph_metadata_manager.py)

Schemas: stored as raw Graph JSON objects for each resource; allow additionalProperties.

### Config values
- `annika:config:default_plan_id` — string plan id used by sync service if set
- Source: [src/planner_sync_service_v5.py](mdc:src/planner_sync_service_v5.py)

Schema:
```json
{"type": "string"}
```

